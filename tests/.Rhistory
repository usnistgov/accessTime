"UHF-Trunked-p25-lab-wired-Vol-11", # uhf trunked lab
"VHF-Direct-p25-lab-wired-Vol-11", # vhf direct lab
"VHF-Trunked-p25-lab-wired-Vol-11" # vhf trunked lab
),
thinning = c(4, # characterization
3, # lab uhf direct
5, # lab uhf trunked
5, # lab vhf direct
5 # lab vhf trunked
)
)
# Two location field test setup information
twoLoc.field <- list(
name = "Two Location Lab",
path = twoLoc.path,
tests = c(
"p25-lab-characterization-2loc", # characterization lab
"UHF-Direct-US36-G", # uhf direct field
"UHF-Trunked-US36-G", #uhf trunked field
"VHF-Direct-US36-G", # vhf direct field
"VHF-Trunked-US36-G" # vhf trunked field
),
thinning = c(4, # characterization
5, # field uhf direct
4, # field uhf trunked
4, # field vhf direct
1 # field vhf trunked
)
)
# Calculate all test values and uncertainties
m2e <- process.sessions(all.setups=list(oneLoc,twoLoc.lab,twoLoc.field))
View(m2e)
m2e$df
View(m2e$df)
help(package="metRology")
a <- "hi"
list(a=1)
?list
a <- list()
a[[NA]] <- "hi"
a[[NULL]] <- "hi"
a[[b]] <- "hi"
?raise
?stop
x <- 3476.8
t <- 0.062
x*t
t*(x-152.98)
t*(x-173.84)
209.93/0.062
x - 209.93/0.062
my_func <- function(x, y='hello', z='world', w){
print(paste(x,y,z,w))
}
my_func(1,2)
my_func(1,2,1)
my_func(1,2,1,5)
my_func(1,w=5)
help(package="minpack.lm")
?approxfun
library(mouth2ear)
open(autocorr.unc)
View(autocorr.unc)
x <- c(0.1,0.5,0.2)
x <- c(0.1,0.5,0.2,rep(4,5))
x
start <- x[1]
seq(from=start,to=length(x),by=2)
seq(from=1,to=length(x),by=2)
s1 <- seq(from=start,to=length(x),by=2)
s2 <- seq(from=1,to=length(x),by=2)
x[s1]
s[s2]
x[s2]
x
s1
seq(from=1,to=11,by=3)
x1 <- list(a=1,b=3)
x2 <- list(a=2,b=5)
x <- list(x1,x2)
x
sapply(x,function(x){x$b})
2112*4.1/60
2112*4.1/60/4
2112*4.1/60/3
library(metRology)
?GUM
library(mouth2ear)
?process.sessions
# Full system path where 1loc data stored
oneLoc.path <- system.file("extdata","Delay_Values", "1loc", package="mouth2ear")
# Full system path where 2loc data stored
twoLoc.path <- system.file("extdata","Delay_Values", "2loc", package="mouth2ear")
# Initialize lists for all test setups used
# One location lab test setup information
oneLoc <- list(
name = "One Location Lab",
path = oneLoc.path,
tests = c(
"1loc-device-characterization",
"1loc-UHF-Direct-wired-p25-lab-Vol-11",
"1loc-UHF-Trunked-wired-p25-lab-Vol-11",
"1loc-VHF-Direct-wired-p25-lab-Vol-11",
"1loc-VHF-Trunked-wired-p25-lab-Vol-11"
),
thinning = c(3, # characterization
4, # uhf direct
4, # uhf trunked
7, # vhf direct
3 # vhf trunked
)
)
# Two location lab test setup information
twoLoc.lab <- list(
name = "Two Location Lab",
path = twoLoc.path,
tests = c(
"p25-lab-characterization-2loc", # characterization lab
"UHF-Direct-p25-lab-wired-Vol-11", # uhf direct lab
"UHF-Trunked-p25-lab-wired-Vol-11", # uhf trunked lab
"VHF-Direct-p25-lab-wired-Vol-11", # vhf direct lab
"VHF-Trunked-p25-lab-wired-Vol-11" # vhf trunked lab
),
thinning = c(4, # characterization
3, # lab uhf direct
5, # lab uhf trunked
5, # lab vhf direct
5 # lab vhf trunked
)
)
# Two location field test setup information
twoLoc.field <- list(
name = "Two Location Lab",
path = twoLoc.path,
tests = c(
"p25-lab-characterization-2loc", # characterization lab
"UHF-Direct-US36-G", # uhf direct field
"UHF-Trunked-US36-G", #uhf trunked field
"VHF-Direct-US36-G", # vhf direct field
"VHF-Trunked-US36-G" # vhf trunked field
),
thinning = c(4, # characterization
5, # field uhf direct
4, # field uhf trunked
4, # field vhf direct
1 # field vhf trunked
)
)
# Calculate all test values and uncertainties
m2e <- process.sessions(all.setups=list(oneLoc,twoLoc.lab,twoLoc.field))
m2e
m2e$thinned.data$One.Location.Lab$`1loc-UHF-Trunked-wired-p25-lab-Vol-11`
m2e$autocorr.data$`1loc-UHF-Trunked-wired-p25-lab-Vol-11`
View(process.sessions)
oneLoc.path
oneLoc_tests <- list.files(oneLoc.path)
oneLoc_tests
tname <- oneLoc_tests[3]
tname <- oneLoc_tests[3]
tpath <- file.path(oneLoc_tests,tname)
tfiles <- list.files(tpath)
tdat <- lapply(tfiles,read.csv)
tdat
tfiles
tpath
tpath <- file.path(oneLoc.path,tname)
tfiles <- list.files(tpath)
tdat <- lapply(tfiles,read.csv)
tfpath <- file.path(tpath,tfiles)
tdat <- lapply(tfpath,read.csv)
tdat
tdat_raw <- lapply(tfpath,read.csv)
tdat <- lapply(tdat_raw,
function(x){
apply(x,1,mean)
})
tdat
um <- lapply(tdat,autocorr.unc)
um
lags <- sapply(um,function(x){x$lag})
lags
ns <- lapply(tdat,length)
ns
tdat_raw <- lapply(tfpath,read.csv,header=FALSE)
tdat <- lapply(tdat_raw,
function(x){
apply(x,1,mean)
})
um <- lapply(tdat,autocorr.unc)
ns <- lapply(tdat,length)
lags <- sapply(um,function(x){x$lag})
thin_factor <- 1
ns
thin_seqs <- lapply(ns, function(x){
seq(from=1,to=x,by=thin_factor)
})
thin_seqs
lags<- rep(inf,length(tdat))
lags<- rep(Inf,length(tdat))
lags
thin_seqs <- lapply(ns, function(x){
seq(from=1,to=x,by=thin_factor)
})
thin_dat <- mapply(function(x,y){
x[y]
},
tdat,thin_seqs,
SIMPLIFY=FALSE)
thin_dat
um <- lapply(tdat,autocorr.unc)
lags <- sapply(um,function(x){x$lag})
lags
while(any(lags > 1)){
thin_seqs <- lapply(ns, function(x){
seq(from=1,to=x,by=thin_factor)
})
thin_dat <- mapply(function(x,y){
x[y]
},
tdat,thin_seqs,
SIMPLIFY=FALSE)
um <- lapply(tdat,autocorr.unc)
lags <- sapply(um,function(x){x$lag})
}
ns <- lapply(tdat,length)
lags<- rep(Inf,length(tdat))
thin_factor <- 1
while(any(lags > 1)){
thin_seqs <- lapply(ns, function(x){
seq(from=1,to=x,by=thin_factor)
})
thin_dat <- mapply(function(x,y){
x[y]
},
tdat,thin_seqs,
SIMPLIFY=FALSE)
um <- lapply(tdat,autocorr.unc)
lags <- sapply(um,function(x){x$lag})
thin_factor <- thin_factor + 1
}
thin_factor <- thin_factor - 1
print(thin_factor)
thin_factor <- 1
while(any(lags > 1)){
thin_seqs <- lapply(ns, function(x){
seq(from=1,to=x,by=thin_factor)
})
thin_dat <- mapply(function(x,y){
x[y]
},
tdat,thin_seqs,
SIMPLIFY=FALSE)
um <- lapply(tdat,autocorr.unc)
lags <- sapply(um,function(x){x$lag})
thin_factor <- thin_factor + 1
print(thin_factor)
}
lags
while(any(lags > 1)){
thin_seqs <- lapply(ns, function(x){
seq(from=1,to=x,by=thin_factor)
})
thin_dat <- mapply(function(x,y){
x[y]
},
tdat,thin_seqs,
SIMPLIFY=FALSE)
um <- lapply(tdat,autocorr.unc)
lags <- sapply(um,function(x){x$lag})
print(lags)
thin_factor <- thin_factor + 1
print(thin_factor)
}
ns <- lapply(tdat,length)
lags<- rep(Inf,length(tdat))
thin_factor <- 1
while(any(lags > 1)){
thin_seqs <- lapply(ns, function(x){
seq(from=1,to=x,by=thin_factor)
})
thin_dat <- mapply(function(x,y){
x[y]
},
tdat,thin_seqs,
SIMPLIFY=FALSE)
um <- lapply(thin_dat,autocorr.unc)
lags <- sapply(um,function(x){x$lag})
print(lags)
thin_factor <- thin_factor + 1
print(thin_factor)
}
thin_factor <- thin_factor - 1
thin_factor
oneLoc_tests
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
thin_factor
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
thin_factor
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
i
i
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
lag_max
length(x)
tdat
x <- tdat[[1]]
x
get_thin_factor(x)
is_autocorr(x)
autocorr_est(x)
ac_info <- autocorr_est(x)
abs(ac_info$rho) > ac_info$bounds
which(!(abs(ac_info$rho) > ac_info$bounds))
thin_factor
thin_factor <- 2
thinned_data <- thin_data(x,thin_factor)
ac_flag <- is_autocorr(thinned_data)
thin_factor <- thin_factor + 1
ac_flag
ac_info <- autocorr_est(thinned_data)
ac_info
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
tname
tpaths <- file.path(oneLoc.path,oneLoc_tests)
tpaths
basename(tpath)
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
help(package="mouth2ear")
source('D:/new-hire-examples/mouth2ear_thin_factors.R')
bad_path <- "C:\Users"
good_path <- "C:/Users"
bad_path <- "C:\\Users"
bad_path
file.exists(bad_path)
stopifnot(FALSE)
stopifnot(TRUE)
x1 <- c(1:10)
x2 <- c(11:20)
source('D:/MCV_671DRDOG/exact_perm_test.R')
dataset1 <- x1
dataset2 <- x2
# get lengths of the datasets
N1 <- length(dataset_1)
N2 <- length(dataset_2)
# assert dataset sizes are equal
stopifnot(N1 == N2)
# pool data
pooled_dataset <- c(dataset_1, dataset_2)
# get all combinations of datapoints. Points reflected in the
# vector are mutually exclusive, so c(a[k], a[-k]) == pooled
combs <- combn(pooled_dataset, N1)
# get lengths of the datasets
N1 <- length(dataset_1)
dataset_1 <- x1
rm(list=ls())
source('D:/MCV_671DRDOG/exact_perm_test.R')
dataset_1 <- c(1:10)
dataset_2 <- c(11:20)
# get lengths of the datasets
N1 <- length(dataset_1)
N2 <- length(dataset_2)
# assert dataset sizes are equal
stopifnot(N1 == N2)
# pool data
pooled_dataset <- c(dataset_1, dataset_2)
# get all combinations of datapoints. Points reflected in the
# vector are mutually exclusive, so c(a[k], a[-k]) == pooled
combs <- combn(pooled_dataset, N1)
nrow(combs)
ncol(combs)
# get mean of all permutations. Mean of all combinations
# of N1 datapoints from the pooled data
means <- colMeans(combs)
variances <- apply(combs, 2, var)
skews <- apply(combs, 2, skew)
out <- list()
aux <- function(x) {
# Separate vector in half. This way, we cut computation time
# in half since the rest of the datapoints are just the
# negative
l <- length(x)
h1 <- x[1:(l/2)]
h2 <- x[(l/2 + 1):l]
# reverse h2
h2 <- rev(h2)
# get differences and compliment. Corresponds to adding the
# mirrored half
tmp <- h2 - h1
tmp <- c(tmp, -tmp)
return(tmp)
}
out <- lapply(list('means'=means, 'vars'=variances, 'skews'=skews), aux)
View(out)
combn(1:10,2)
combn(1:6,2)
combn(1:6,3)
ac <- combn(1:6,3)
l <- length(ac)
l
ac[1:30]
ac
am <- colmeans(ac)
am <- colMeans(ac)
am
l <- length(am)
h1 <- am[1:(l/2)]
h2 <- am[(l/2+1):l]
h1
h2
h2 <- rev(h2)
h2
am[l:(l/2+1)]
tmp <- h2-h1
tmp
tmp <- c(tmp,-tmp)
tmp
combs
ac
ac
ac[,1:10]
ac[,20:11]
?approxfun
x1 <- 2
x2 <- 3
y1 <- 4
y2 <- 5
A <- matrix(c(x1, 1, x2, 1),nrow=2,ncol=2)
A
A <- matrix(c(x1, x2, 1, 1),nrow=2,ncol=2)
A
y <- c(y1,y2)
solve(A,y)
any(c(4,5))
any(c(TRUE,TRUE))
is_even <- function(x){
# Function to determine if a number is even or not. Returns true if even, false if odd
even_flag <- x/2 == floor(x/2)
}
is_even(4)
is_even <- function(x){
# Function to determine if a number is even or not. Returns true if even, false if odd
even_flag <- x/2 == floor(x/2)
return(even_flag)
}
is_even(4)
is_even(5)
is_even(5.5)
is_even(5.4)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
library(accessTime)
open(process_accessData())
View(process_accessData())
View(process_accessData
)
packageVersion(accessTime)
packageVersion("accessTime")
source('~/.active-rstudio-document', echo=TRUE)
getwd)()
getwd)()
getwd()
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
knitr::opts_chunk$set(echo = TRUE)
setwd("D:MCV_671DRDOG/psud-internal")
getwd()
source('~/.active-rstudio-document', echo=TRUE)
help(package="mouth2ear")
library(accessTime)
write.csv(ptt_gate$`F1 bed`$curve_dat,"curve_dat.csv")
getwd()
dat <- ptt_gate$`F1 bed`$curve_dat
dat
dat$`F1 bed`$PTT
write.csv(ptt_gate$`F1 bed`$curve_dat$`F1 bed`$PTT,"curve_dat.csv")
ptt_gate$`F1 bed`$I0
ptt_gate$`F1 bed`
vcov(ptt_gate$`F1 bed`)
help(package="accesstime")
help(package="accessTime")
mu <- 0.9779
sig <- 0.049876
ci <- c(0.943396, 1.056604)
mu - c(1, -1)*ci
mu -ci[1]
mu -ci[2]
ci[2] - mu
unc <- 0.078704
unc/1.96
sig/sqrt(1200)
unc/2
sig/sqrt(1200)
1.96*sig/sqrt(1200)
source('D:/MCV_671DRDOG/access-release/tests/generate_reference_data.R')
res
source('D:/MCV_671DRDOG/access-release/tests/generate_reference_data.R')
quit()
source('D:/MCV_671DRDOG/access-release/tests/generate_reference_data.R')
source('D:/MCV_671DRDOG/access-release/tests/generate_reference_data.R')
